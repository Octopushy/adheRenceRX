---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# adheRenceRX

Check out our site [adheRenceRX](https://btbeal.github.io/adheRenceRX/) 
<!-- badges: start -->
<!-- badges: end -->

The goal of adheRenceRX is to provide a slightly opinionated set of functions to allow researchers to assess medication adherence in the most flexible way possible. The goal was (is) to write piping-friendly verbs the "tidy" way to allow users to manipulate their data as they'd like without storing data multiple times into their environment. The final value is that our looping functions are written with C++ allowing speed and performance when you'd rather do research than run a function for an hour!  
  
This was a lot of fun to build but is still in production. If you find errors, or know things you'd like to see done differently, reach out!

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("btbeal/adheRenceRX")
```
## Overview

Much of the inspiration for this package came from conversations with analysts who struggle to deal with the non-intuitive ways to deal with medication adherence calculations from pharmaceutical claims data. Primarily, how should we adjust days where a patient presumably has a double supply (i.e., when a patient has filled a medication prior to their assumed next fill date).  
  
Our package is built around suggestions from Canfield and colleagues (2019) who note that overlapping fill dates should be pushed forward and never counted backwards, and I agree. For that reason, our package revolves around the first step of creating adjusted dates prior to any other calculation.  
  
Our verbs to date are:  
  
  - `propagate_date()`
  - `identify_gaps()` or `summarise_gaps()`
  - `rank_episodes()`
  - `calculate_pdc()`

For the most part, our verbs assume that dates have been propagated forward and gaps have been properly identified. This is on purpose but is subject to change in the future.  

## Examples

More examples of use can be found on within each functions documentation; however, this should provide a decent overview of how the package is to be used.  
  

```{r example1}
library(adheRenceRX)
library(dplyr)

# manipulate toy_claims, which has IDs based on the Canfield 2019 paper 
toy_claims %>% 
  # filter for some interesting IDs
  filter(ID %in% c("B", "D")) %>% 
  # Group by them (grouping not limited, of course)
  group_by(ID) %>% 
  # propagate the dates forward within those groups
  propagate_date(date_var = date, days_supply_var = days_supply)
```
  
Notice that several rows have been pushed forward to account for overlaps in date. Also notice that the output changes the date and days supply variable to `date` and `days_supply` while adding an `adjusted_date` variable. The `adjusted_date` variable is used by some of the other functions so it is important to complete this step first.  
  
Once the dates have been adjusted, we can identify gaps in therapy with `identify_gaps()` or summarise them with `summarise_gaps()`.

```{r example2}
# The same code from above
toy_claims %>% 
  filter(ID %in% c("B", "D")) %>% 
  group_by(ID) %>% 
  propagate_date(date_var = date, days_supply_var = days_supply) %>% 
  # But now we can identify gaps
  identify_gaps()


# Or, we could just summarise them all:
toy_claims %>% 
  filter(ID %in% c("B", "D")) %>% 
  group_by(ID) %>% 
  propagate_date(date_var = date, days_supply_var = days_supply) %>% 
  # Summarising gaps
  summarise_gaps()
```

With the gaps identified, we can check for episodes of care using our `rank_episodes()` functions. Note that this function assumes that you've propagated your dates appropriately and identified all gaps. You can then tell our function what can be considered a permissible gap, and everything after a gap that large or more will be considered the next episode! Let me show you.  
  
```{r example3}
# The same code from above
toy_claims %>% 
  filter(ID %in% c("B", "D")) %>% 
  group_by(ID) %>% 
  propagate_date(date_var = date, days_supply_var = days_supply) %>% 
  # But now we can identify gaps
  identify_gaps() %>% 
  # say that anything over a 10 day gap should count as the next episode
  rank_episodes(.permissible_gap = 10)
```
  
Finally, an actual adherence calculation. This is fairly straightforward since the bulk of the work has been done adjusting your dates and then appropriately identifying the gaps in therapy. Still, more functions = more fun!  
  
```{r calculations}
toy_claims %>% 
  group_by(ID) %>% 
  propagate_date() %>% 
  identify_gaps() %>% 
  # tell our function what the boundaries are
  calculate_pdc(.max_date = "2020-07-28", .min_date = "2020-01-01")
```
## Enjoy!

That's all we have for now. Again, this package is meant to provide some helper functions with the meat of the project coming from our `propagate_date()` and `rank_episodes()`. Notbaly, those tasks can't be accomplished with `dplyr` alone (as they do not have vectorised solutions). For this reason, we've written some C++ functions to help you speed up the task!  
  
## Citations
  
  1. Canfield SL, Zuckerman A, Anguiano RH, Jolly JA, DeClercq J.Navigating the wild west of medication adherence reporting in specialty pharmacy. J Manag Care Spec Pharm. 2019;25(10):1073-77.